/**
ILI9341 XPT2046 Driver, for touch screen functionality
  */ 
#include "xpt2046.h"
#include "ili9341.h"
#include "fonts.h"
#include <stdio.h> 
#include <string.h>

/*******************************  XPT2046 ***************************/
static void                   XPT2046_DelayUS                       ( __IO uint32_t ulCount );
static void                   XPT2046_WriteCMD                      ( uint8_t ucCmd );
static uint16_t               XPT2046_ReadCMD                       ( void );
static uint16_t               XPT2046_ReadAdc                       ( uint8_t ucChannel );
static void                   XPT2046_ReadAdc_XY                    ( int16_t * sX_Ad, int16_t * sY_Ad );
static uint8_t                XPT2046_ReadAdc_Smooth_XY             ( strType_XPT2046_Coordinate * pScreenCoordinate );




volatile uint8_t ucXPT2046_TouchFlag = 0;




void XPT2046_Init ( void )
{
  GPIO_InitTypeDef  GPIO_InitStructure;
	 /* GPIOʱ */
	__HAL_RCC_GPIOE_CLK_ENABLE();
	__HAL_RCC_GPIOD_CLK_ENABLE();
 
  /* ģSPI GPIOʼ */
  GPIO_InitStructure.Pin=XPT2046_SPI_CLK_PIN;
  GPIO_InitStructure.Speed=GPIO_SPEED_FREQ_HIGH ;	  
  GPIO_InitStructure.Mode=GPIO_MODE_OUTPUT_PP;
  HAL_GPIO_Init(XPT2046_SPI_CLK_PORT, &GPIO_InitStructure);

  GPIO_InitStructure.Pin = XPT2046_SPI_MOSI_PIN;
  HAL_GPIO_Init(XPT2046_SPI_MOSI_PORT, &GPIO_InitStructure);
	

	GPIO_InitStructure.Pin = XPT2046_SPI_CS_PIN; 
  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH ;
  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;      
  HAL_GPIO_Init(XPT2046_SPI_CS_PORT, &GPIO_InitStructure); 
	

  GPIO_InitStructure.Pin = XPT2046_SPI_MISO_PIN; 
  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH ;
  GPIO_InitStructure.Mode = GPIO_MODE_INPUT;  //
	GPIO_InitStructure.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(XPT2046_SPI_MISO_PORT, &GPIO_InitStructure);

  /* ƬѡѡXPT2046 */
  XPT2046_CS_DISABLE();		
								
	//źָʾţʹж
  GPIO_InitStructure.Pin = XPT2046_PENIRQ_GPIO_PIN;       
  GPIO_InitStructure.Mode = GPIO_MODE_INPUT;  //
	GPIO_InitStructure.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(XPT2046_PENIRQ_GPIO_PORT, &GPIO_InitStructure);
}




static void XPT2046_DelayUS ( __IO uint32_t ulCount )
{
	uint32_t i;
	for ( i = 0; i < ulCount; i ++ )
	{
		uint8_t uc = 12;
		while ( uc -- );
	}
}


static void XPT2046_WriteCMD ( uint8_t ucCmd ) 
{
	uint8_t i;
	XPT2046_MOSI_0();	
	XPT2046_CLK_LOW();
	for ( i = 0; i < 8; i ++ ) 
	{
		if( ( ucCmd >> ( 7 - i ) ) & 0x01 )
		{
			XPT2046_MOSI_1()
		}else
		{
			XPT2046_MOSI_0();
		}
	  XPT2046_DelayUS ( 5 );
		XPT2046_CLK_HIGH();
	  XPT2046_DelayUS ( 5 );
		XPT2046_CLK_LOW();
	}
	
}

static uint16_t XPT2046_ReadCMD ( void ) 
{
	uint8_t i;
	uint16_t usBuf=0, usTemp;
	XPT2046_MOSI_0();
	XPT2046_CLK_HIGH();
	for ( i=0;i<12;i++ ) 
	{
		XPT2046_CLK_LOW();    
		usTemp = XPT2046_MISO();
		usBuf |= usTemp << ( 11 - i );
		XPT2046_CLK_HIGH();
	}
	return usBuf;
}


static uint16_t XPT2046_ReadAdc ( uint8_t ucChannel )
{
	XPT2046_WriteCMD ( ucChannel );

  return 	XPT2046_ReadCMD ();
	
}

static void XPT2046_ReadAdc_XY ( int16_t * sX_Ad, int16_t * sY_Ad )  
{ 
	int16_t sX_Ad_Temp, sY_Ad_Temp; 
	
	sX_Ad_Temp = XPT2046_ReadAdc ( XPT2046_CHANNEL_X );

	XPT2046_DelayUS ( 1 ); 

	sY_Ad_Temp = XPT2046_ReadAdc ( XPT2046_CHANNEL_Y ); 
	
	
	* sX_Ad = sX_Ad_Temp; 
	* sY_Ad = sY_Ad_Temp; 
}

static uint8_t XPT2046_ReadAdc_Smooth_XY ( strType_XPT2046_Coordinate * pScreenCoordinate )
{
	uint8_t ucCount = 0, i;
	
	int16_t sAD_X, sAD_Y;
	int16_t sBufferArray [ 2 ] [ 10 ] = { { 0 },{ 0 } };
	

	int32_t lX_Min, lX_Max, lY_Min, lY_Max;



	do					       				
	{		  
		XPT2046_ReadAdc_XY ( & sAD_X, & sAD_Y );  
		
		sBufferArray [ 0 ] [ ucCount ] = sAD_X;  
		sBufferArray [ 1 ] [ ucCount ] = sAD_Y;
		
		ucCount ++;  
		
	}	while ( ( XPT2046_PENIRQ_Read() == XPT2046_PENIRQ_ActiveLevel ) && ( ucCount < 10 ) );
	
	

	if ( XPT2046_PENIRQ_Read() != XPT2046_PENIRQ_ActiveLevel )
		ucXPT2046_TouchFlag = 0;

	

	if ( ucCount ==10 )		 					
	{
		lX_Max = lX_Min = sBufferArray [ 0 ] [ 0 ];
		lY_Max = lY_Min = sBufferArray [ 1 ] [ 0 ];       
		
		for ( i = 1; i < 10; i ++ )
		{
			if ( sBufferArray[ 0 ] [ i ] < lX_Min )
				lX_Min = sBufferArray [ 0 ] [ i ];
			
			else if ( sBufferArray [ 0 ] [ i ] > lX_Max )
				lX_Max = sBufferArray [ 0 ] [ i ];

		}
		
		for ( i = 1; i < 10; i ++ )
		{
			if ( sBufferArray [ 1 ] [ i ] < lY_Min )
				lY_Min = sBufferArray [ 1 ] [ i ];
			
			else if ( sBufferArray [ 1 ] [ i ] > lY_Max )
				lY_Max = sBufferArray [ 1 ] [ i ];

		}
		
		

		pScreenCoordinate ->x =  ( sBufferArray [ 0 ] [ 0 ] + sBufferArray [ 0 ] [ 1 ] + sBufferArray [ 0 ] [ 2 ] + sBufferArray [ 0 ] [ 3 ] + sBufferArray [ 0 ] [ 4 ] + 
		                           sBufferArray [ 0 ] [ 5 ] + sBufferArray [ 0 ] [ 6 ] + sBufferArray [ 0 ] [ 7 ] + sBufferArray [ 0 ] [ 8 ] + sBufferArray [ 0 ] [ 9 ] - lX_Min-lX_Max ) >> 3;
		
		pScreenCoordinate ->y =  ( sBufferArray [ 1 ] [ 0 ] + sBufferArray [ 1 ] [ 1 ] + sBufferArray [ 1 ] [ 2 ] + sBufferArray [ 1 ] [ 3 ] + sBufferArray [ 1 ] [ 4 ] + 
		                           sBufferArray [ 1 ] [ 5 ] + sBufferArray [ 1 ] [ 6 ] + sBufferArray [ 1 ] [ 7 ] + sBufferArray [ 1 ] [ 8 ] + sBufferArray [ 1 ] [ 9 ] - lY_Min-lY_Max ) >> 3; 
		
		
		return 1;		
		
	}   	
	return 0;    	
}



   
uint8_t XPT2046_Get_TouchedPoint ( strType_XPT2046_Coordinate * pDisplayCoordinate, strType_XPT2046_TouchPara * pTouchPara )
{
	uint8_t ucRet = 1;
	
	strType_XPT2046_Coordinate strScreenCoordinate; 
	

  if ( XPT2046_ReadAdc_Smooth_XY ( & strScreenCoordinate ) )
  {    
		pDisplayCoordinate ->x = ( ( pTouchPara[LCD_SCAN_MODE].dX_X * strScreenCoordinate.x ) + ( pTouchPara[LCD_SCAN_MODE].dX_Y * strScreenCoordinate.y ) + pTouchPara[LCD_SCAN_MODE].dX );        
		pDisplayCoordinate ->y = ( ( pTouchPara[LCD_SCAN_MODE].dY_X * strScreenCoordinate.x ) + ( pTouchPara[LCD_SCAN_MODE].dY_Y * strScreenCoordinate.y ) + pTouchPara[LCD_SCAN_MODE].dY );

  }
	 
	else ucRet = 0;
		
  return ucRet;
} 

void XPT2046_TouchEvenHandler(void )
{
	  static strType_XPT2046_Coordinate cinfo={-1,-1,-1,-1};

		if(XPT2046_TouchDetect() == TOUCH_PRESSED)
		{
			LED_GREEN;

			//获取触摸坐标
			XPT2046_Get_TouchedPoint(&cinfo,strXPT2046_TouchPara);

			//输出调试信息到串口
			XPT2046_DEBUG("x=%d,y=%d",cinfo.x,cinfo.y);

			//调用触摸被按下时的处理函数，可在该函数编写自己的触摸按下处理过程
			XPT2046_TouchDown(&cinfo);

			/*更新触摸信息到pre xy*/
			cinfo.pre_x = cinfo.x; cinfo.pre_y = cinfo.y;

		}
		else
		{
			LED_BLUE;

			//调用触摸被释放时的处理函数，可在该函数编写自己的触摸释放处理过程
			XPT2046_TouchUp(&cinfo);

			/*触笔释放，把 xy 重置为负*/
			cinfo.x = -1;
			cinfo.y = -1;
			cinfo.pre_x = -1;
			cinfo.pre_y = -1;
		}

}

/***************************end of file*****************************/


